
---
### 执行逻辑

用户代码本质上是字符串，所以当RML解释器获取到用户的输入时，首先要做的就是对字符串进行处理。例如输入

```
print "Hello world"
```
解释器首先会按照RML的数据类型的格式，将字符串分割为一系列子字符串。主要的分割标志是所有的空白字符，包括空格、换行、制表符等。但在遇到集合类型时，首先会忽略这些空白字符，而是向后查找直到集合闭合，整个集合被视为一个Token，其内部另行分割。集合的判断标识主要是 `" "`, `[ ]`, `( )`, `{ }`
</br>
因此，上面的代码会被分割为两部分 `print`和`"Hello world"`
</br></br>
在获得子字符串序列后，需要根据各个子字符串的字面格式，将其转换为对应数据类型的Token（具体格式参见数据类型文档）。以上的代码会转换得到两个Token，其中 `print` 是单字类型，`"Hello world"` 是字符串类型。
</br></br>
完成Token的转换后，就进入执行阶段。RML的执行单元称为EvalStack，其底层是一个*Token数组，并维护了栈指针和栈操作相关的方法。另外EvalStack中维护了用于存放各层级表达式起止点的StartPos和EndPos，底层是int数组，并实现了List的功能。
</br></br>
开始启动执行逻辑时，EvalStack的栈指针指向0的位置。此时解释器读到一个单字类型的 `print`，由于单字类型是用于绑定对应的值，所以此时解释器就会沿着语境树向上查找 `print` 的绑定。如果你没有自定义覆盖 `print`，解释器就会从最顶层的 `lib` 语境中找到 `print` 的绑定，是一个函数 `func!`类型的Token，于是将这个Token推入栈中0的位置，栈指针向后移动一位，指向1。
</br>
对于函数，除了推入栈中外，还要记住函数表达式的起止位置。由于目前 `print` 函数的位置在0，所以首先在StartPos中放入一个0，此时的StartPos为
</br>

```
[0]
```
然后解释器根据函数 `print` 的定义，得知其需要一个参数，则表达式的长度为2，接下来想EndPos中放入 `0 + 2`，此时的EndPos为
</br>

```
[2]
```
EvalStack每推入一个Token后，都会检查当前表达式是否完整。若栈指针指向EndPos的最后一个值时，说明当前表达式完整，调用EvalExp方法对表达式求值。
</br>
此时栈指针指向1，而EndPos的最后一个值是2，说明当前表达式不完整，解释器继续加载Token。接着载入的是 `Hello world`，这是一个字符串类型的Token，表示一个具体的值，不会新建表达式。EvalStack在当前栈指针指向的1位置推入 `Hello world`，栈指针后移一位指向2。此时检查表达式，发现表达式完整，调用EvalExp方法。
</br>
</br>
EvalExp方法首先检查StartPos的最后一个值指向的Token，也就是当前表达式头部的Token。如头部Token是设字类型，则进行绑定操作，若为原生函数或函数类型，则调用对应的方法进行求值。这里的 `print`是一个函数，其内部调用了一个原生函数 `_print` ，最终实现将其后一个Token按字面值格式化后，输出到控制台上。
</br>
</br>
对于表达式嵌套的处理方式与上面的单个表达式一致，只是StartPos和EndPos的长度向后延伸。例如输入

```
print 1 + 2
```
这里还涉及到了中缀运算符的处理，解释器每加载一个Token时，都会向后检查一个Token，若发现时中缀类型的Token，则采取相应的加载顺序。
</br>
首先载入了一个函数 `print`，此时的StartPos为 `[0]` ， EndPos为 `[2]`
接着在载入 `1` 时，发现其后的 `+` 对应一个中缀类型的Token，则首先向栈中推入 `+`，再推入`1`，栈指针向后移2位来到3。
</br>
由于中缀运算的表达式长度恒为3，所以此时StartPos为 `[0 1]`, EndPos为 `[2 4]`
</br>
接着载入 `2`，栈指针指向4。此时栈指针等于EndPos的最后一个值，表达式完整，调用EvalExp执行 `[ + 1 2 ]`，结果为`3`，EvalStack会把结果放到StartPos的最后一个值指向的位置，也就是表达式头部的位置换成执行结果，并把栈指针移动到表达式头部的后一位，此时指向2。
</br>
完成表达式的返回值的设置后，还要清理StartPos和EndPos，各自弹出末尾的一个值。此时StartPos为`[0]`，EndPos为`[2]`。
</br>
每完成一个表达式求值，都要再检查当前表达式是否完整，有可能由于子表达式求值后使当前表达式完整。此时发现栈指针指向2，等于EndPos的最后一个值，则函数 `print` 的表达式完整，在调用EvalExp求值，最终在控制台输出 `3`。
</br></br>
以上就是RML的基本执行逻辑和实现方式。














