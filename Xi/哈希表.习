#包含 "习语言系统.接口"

#包含 "令牌.习"


类型定义 结构类型 哈希桶{
	字符			*键;
	令牌			*值;
	哈希桶		*次位;
} ;


自然数 求哈希值(字符 *句, 自然数 长度){
	自然数 种子 = 131;
	自然数 哈希 = 0;
	自然数 甲 = 0;
	
	步进循环(甲 = 0; 甲 < 长度; 句++, 甲++){
		哈希 = (哈希 * 种子) + (*句);
	}
	返回 哈希;
}

类型定义 结构类型 哈希表{
	自然数	容量;
	自然数	桶数;
	哈希桶	*桶列;
};


哈希表 哈希表扩容(哈希表 *表, 整数类型 增量);


自然数 插入哈希表(哈希表 *表, 字符 *键, 令牌 *令){
	令牌 *插入值 = 内存申请并清零(类型长度(令牌));
	内存复制(令, 插入值, 类型长度(令牌));

	自然数 索引值 = 求哈希值(键, 字符串长度(键)) % (*表).容量;	
	哈希桶 *桶 = &((*表).桶列[索引值]);
	如果((*桶).键 等于 空指针){
		
		(*桶).键 = 键;
		(*桶).值 = 插入值;
		(*表).桶数++;
	}否则{
		当(((*桶).次位 不等于 空指针) 并且 (字符串比较((*桶).键, 键) 不等于 0))重复{
			(*桶) = *(*桶).次位;
		}
		如果(字符串比较((*桶).键, 键) 等于 0){
			(*桶).值 = 插入值;	
		}否则{
			哈希桶 新桶;
			新桶.键 = 键;
			新桶.值 = 插入值;
			(*桶).次位 = &新桶;
			(*表).桶数++;
		}	
	}

	如果((*表).桶数 > ((*表).容量 / 4 * 3)){
		(*表) = 哈希表扩容(表, (*表).容量);	
	}
	返回 索引值;
}


令牌 *取哈希表项(哈希表 *表, 字符 *键){
	如果(键 等于 空指针){
		返回 空指针;
	}
	自然数 索引值 = 求哈希值(键, 字符串长度(键)) % (*表).容量;
	如果((*表).桶列[索引值].键 不等于 空指针){
		哈希桶 桶 = (*表).桶列[索引值];
		重复{
			如果( (桶.键 不等于 空指针) 并且 (字符串比较(桶.键, 键) 等于 0)){
				返回 桶.值;	
			}否则{
				桶 = *桶.次位;	
			}
		}直到(桶.次位 等于 空指针);
	}
	令牌 *令 = 内存申请并清零(类型长度(令牌));
	(*令).类型 = 1;
	(*令).值空间.字面值 = "空";
	(*令).句长 = 1;
	
	返回 令;
}

哈希表 新哈希表(自然数 容量){
	哈希表 表;
	如果(容量 等于 0){
		返回 表;	
	}
	表.容量 = 容量;
	表.桶数 = 0;
	
	哈希桶 *桶列 = 内存申请并清零(容量 * 类型长度(哈希桶));
	
	表.桶列 = 桶列;		
	返回 表;
}


哈希表 哈希表扩容(哈希表 *表, 整数类型 增量){
	哈希表 新表 = 新哈希表((*表).容量 + 增量);
	步进循环(整数 序 = 0; 序 小于 (*表).容量; 序++ ){
		哈希桶 桶;
		如果((*表).桶列[序].键 不等于 空指针){
			桶 = (*表).桶列[序];
			重复{
				插入哈希表(&新表, 桶.键, 桶.值);
				如果(桶.次位 不等于 空指针){
					桶 = *桶.次位;
				}	
			}直到(桶.次位 等于 空指针);			
		}	
	}
	内存释放((*表).桶列);
	内存释放(表);
	
	返回 新表;
}



//测试
/*
整数类型 主函数( ){ 
	
	令牌 测试令牌;
	测试令牌.类型 = 0;
	测试令牌.值空间.字面值 = “字面值”;
	输出字符串并换行(测试令牌.值空间.字面值);
	暂停();
	
	
	
	哈希表 表 = 新哈希表(1);
	
	插入哈希表(&表, "123", &测试令牌);
	
	
	令牌 牌 = *取哈希表项(表, "123");
	

	格式输出("旧表容量为%整   桶数为%整", 表.容量, 表.桶数);
	
	暂停();
	
	哈希表 新表 = 哈希表扩容(&表, 16);
	令牌 新牌 = *取哈希表项(新表, "123");
	格式输出("%整   %整", 新表.容量, 新表.桶数);
	换行();
	暂停();
	输出字符串(新牌.值空间.字面值);
	换行();
	
	
	返回 0;	
}
*/












