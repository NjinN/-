#包含 "习语言系统.接口"

#包含 "作业线.习"

类型定义 结构类型 作业器 {
	容器	*境;
	作业线	*线;	
};

无类型 执行序（作业器 处理器， 令牌 *令牌组）{
	
	如果(令牌组 等于 空指针){
		返回;	
	}
	
	自然数 令牌组长 = 0；
	当（令牌组[令牌组长].类型 不等于 0）重复{
		令牌组长++;	
	}
	
	令牌 *临时令牌 = 内存申请并清零(类型长度(令牌));
	整数 序 = 0；
	作业线 *当前线 = 处理器.线;
	
	当（序 小于等于 (令牌组长 - 1)）重复{
		/*
		格式输出("当前序号为%整\n", 序);
		格式输出("当前令牌为%串\n", 取字面值(&令牌组[序]));
		*/
		
		如果(令牌组[序 + 1].类型 等于 _中缀){
			作业线 *新线 = 内存申请并清零(类型长度(作业线));
			(*新线).线长 = 3;
			(*新线).序号 = 3;
			(*新线).境 = (*当前线).境;
			(*新线).栈 = 内存申请并清零(4 * 类型长度(令牌));
			(*新线).父 = 当前线;
			内存复制(令牌组 + 序 + 1, (*新线).栈, 类型长度(令牌));
			内存复制(取值(当前线, 令牌组 + 序), (*新线).栈 + 1, 类型长度(令牌));
			内存复制(取值(当前线, 令牌组 + 序 + 2), (*新线).栈 + 2, 类型长度(令牌));
			序 += 3;
			临时令牌 = 执行线(新线);
			当(令牌组[序].类型 等于 _中缀)重复{
				(*新线).序号 = 3;
				内存复制(令牌组 + 序, (*新线).栈, 类型长度(令牌));
				内存复制(临时令牌, (*新线).栈 + 1, 类型长度(令牌));
				内存复制(取值(当前线, 令牌组 + 序 + 1), (*新线).栈 + 2, 类型长度(令牌));
				内存释放(临时令牌);
				临时令牌 = 执行线(新线);
				序+=2;	
			}
			序--;
			内存复制(临时令牌, (*当前线).栈 + (*当前线).序号, 类型长度(令牌));		
		}否则{
			如果((*当前线).序号 等于 0){
				内存复制(令牌组 + 序, (*当前线).栈 + (*当前线).序号, 类型长度(令牌));
			}否则{
				如果(令牌组[序].类型 大于 0){
					内存复制(取值(当前线, &令牌组[序]), (*当前线).栈 + (*当前线).序号, 类型长度(令牌));		
				}否则{
					作业线 *新线 = 内存申请并清零(类型长度(作业线));
					(*新线).线长 = 令牌组[序].句长;
					(*新线).序号 = 0;
					(*新线).境 = (*当前线).境;
					(*新线).栈 = 内存申请并清零((令牌组[序].句长 + 1) * 类型长度(令牌));
					(*新线).父 = 当前线;
					当前线 = 新线;
					内存复制(令牌组 + 序, (*当前线).栈 + (*当前线).序号, 类型长度(令牌));
				}	
			}	
		}

		(*当前线).序号++;
		序++;
		/*
		格式输出("当前线序号为%整\n", (*当前线).序号);
		格式输出("当前线句长为%整\n", (*(*当前线).栈) .句长);
		*/
		临时令牌 = 执行线(当前线);
		当(临时令牌 不等于 空指针 并且 (*当前线).父 不等于 空指针)重复{
			内存复制(临时令牌, (*((*当前线).父)).栈 + (*((*当前线).父)).序号, 类型长度(令牌));
			//内存释放(临时令牌);
			内存释放((*当前线).栈);
			当前线 = (*当前线).父;
			(*当前线).序号++;
			临时令牌 = 执行线(当前线);
		}
		

		如果(临时令牌 不等于 空指针 并且 序 等于 令牌组长){	
			输出字符串("== ");
			输出字符串并换行(取字面值(临时令牌));
		}
	}	
}


/*
无类型 主函数( ){
	作业器 处理器;	
		
}
*/










