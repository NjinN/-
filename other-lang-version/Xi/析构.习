#包含 "习语言系统.接口"

//#包含	"容器.习"
//#包含	"字符串工具.习"

#包含	"转令牌.习"


字符 **分词(字符 *句){
	字符串清除尾部空格(句);
	如果(字符串长度(句) 等于 0){
		返回 空指针;	
	}
	
	自然数 词组长 = 100;
	字符 **词组 = 内存申请并清零(词组长);
	自然数 词序 = 0;
	字符 *词;
	字符 *词尾;

	重复{
		句 = 查找非空符(句);	
		如果(判断头串(句, "\"")){
			词尾 = 筛查子串(句 + 1, "\"", "^\"");	
		}否则 如果(判断头串(句, "\“") ){
			词尾 = 筛查子串(句 + 1, "\"", "^\”");	
		}否则{
			词尾 = 查找空符(句); 	
		}
		
		如果(词尾 等于 空指针){
			词尾 = 查找空符(句);	
		}
		
		词 = 内存申请并清零(词尾 - 句 + 1);
		内存复制(句, 词, 词尾 - 句);
		如果(词序 大于 (词组长 - 1)){
			词组 = 内存重新申请(词组, 词组长 * 2);
			内存填充(词组 + 词组长, 0, 词组长);
			词组长 *= 2;	
		}
		
		词组[词序] = 词;
		词序++;	
		句 = 词尾;	
	}直到(*句 等于 0);
	
	返回 词组;	
}

令牌 *转令牌组(字符 **词组, 容器 *境, 自然数 行号){
	如果(词组 等于 空指针){
		返回 空指针;	
	}
	
	自然数 词组长 = 0;
	当(词组[词组长] 不等于 空指针){
		词组长++;
	}
	
	如果(词组长 等于 0){
		返回 空指针;	
	}
	
	令牌 *令牌组 = 内存申请并清零((词组长 + 1) * 类型长度(令牌));
	
	步进循环(自然数 序 = 0; 序 < 词组长; 序++){
		令牌 *临时令牌 = 内存申请并清零(类型长度(令牌));
		临时令牌[0] = 字符串转令牌(*(词组 + 序), 境, 行号);
		内存复制(临时令牌, 令牌组 + 序, 类型长度(令牌));
		内存释放(临时令牌);
	}
	返回 令牌组;
		
}


/*

无类型 主函数(){
	
	字符 *句 = 内存申请并清零(1000);
	
	输入字符串(句, 1000);
	
	//字符 **词组 = 重组词(拆分词(句));
	//字符 **词组 = 分词(句);
	
	令牌 *令牌组 = 转令牌组(分词(句), 空指针, 1);
	
	当((*令牌组).类型 不等于 0)重复{
		输出整数((*令牌组).类型, 10);
		换行();
		输出字符串((*令牌组).值空间.字面值);
		换行();
		令牌组++;
		输出整数((整数类型)令牌组, 10);
		暂停();
	}
	
	输出字符串("完成显示");
	暂停();	
	
}

*/













